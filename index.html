<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Etch ì •ë©´ ìŠ¹ë¶€!</title>
<meta name="google-site-verification" content="iKMWhIIx2FvXkJssPQrkBkPUqs7ZYKvW_sOlRQ9YJYM" />
<meta name="title" content="ì—ì¹˜ ëŒ€ê²°">
<meta name="description" content="ì—ì¹˜ ëŒ€ê²°">
<meta name="keywords" content="etch roullette,ì—ì¹˜ ë£°ë ›, ì—ì¹˜ë£°ë ›, ë¨í”„ ë£°ë ›, ë¨í”„ë£°ë ›, lamps1c, lamps1cë£°ë › lamps1c ë£°ë ›, ì—ì¹˜ ì •ë©´ëŒ€ê²°">
<meta name="robots" content="index, follow">
<style>
:root{
--bg:#0b0f14; --panel:#0f1622; --grid:#111827;
--accent:#22d3ee; --violet:#a78bfa; --ok:#10b981; --warn:#f59e0b; --danger:#ef4444;
--text:#e5e7eb; --muted:#94a3b8;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:var(--text);
font-family:ui-sans-serif,system-ui,"Pretendard","Noto Sans KR","Apple SD Gothic Neo";}
.wrap{display:grid;grid-template-columns:320px 1fr 360px;gap:16px;
max-width:1400px;margin:22px auto;padding:0 16px}
@media (max-width:1200px){.wrap{grid-template-columns:1fr}}
.card{background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02));
border:1px solid rgba(255,255,255,.08); border-radius:16px; overflow:hidden;
box-shadow:0 10px 30px rgba(0,0,0,.35)}
.card h2{margin:0;padding:12px 14px;border-bottom:1px solid rgba(255,255,255,.06);
background:linear-gradient(90deg, rgba(34,211,238,.12), transparent 40%)}
.controls{padding:12px 14px; display:grid; gap:10px}
textarea{width:100%; height:110px; background:#0b1020; color:var(--text);
border:1px solid rgba(255,255,255,.12); border-radius:12px; padding:10px}
.row{display:flex; gap:8px; flex-wrap:wrap}
button{cursor:pointer; background:#1f2937; color:var(--text);
border:1px solid rgba(255,255,255,.14); padding:10px 12px; border-radius:12px}
button.primary{background:linear-gradient(180deg,#0ea5e9,#1d4ed8); color:white; border-color:#38bdf8}
button.warn{background:linear-gradient(180deg,#f59e0b,#b45309); color:#111}
button:disabled{opacity:.55; cursor:not-allowed}
.tags{display:flex; flex-wrap:wrap; gap:6px; padding:4px 0}
.tag{padding:6px 10px; border-radius:999px; font-size:12px;
background:rgba(167,139,250,.12); border:1px solid rgba(167,139,250,.35)}
.log{padding:10px 14px; height:210px; overflow:auto; font-size:12px;
font-family:ui-monospace, Menlo, Consolas, monospace; background:#0b1020;
border-top:1px solid rgba(255,255,255,.06)}
.status{padding:10px 12px; display:grid; gap:8px}
.chip{display:flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px;
background:rgba(34,211,238,.08); border:1px dashed rgba(34,211,238,.4); font-size:12px}
.stageWrap{position:relative}
#stage{width:100%; height:600px; display:block; background:#0a0f18; border-radius:16px}
.board{padding:10px 12px}
.board table{width:100%; border-collapse:collapse; font-size:14px}
.board th,.board td{border-bottom:1px solid rgba(255,255,255,.08); padding:8px 6px; text-align:left}
.pill{padding:2px 8px; border-radius:999px; font-size:12px; display:inline-block}
.ok{background:rgba(16,185,129,.15); border:1px solid rgba(16,185,129,.45); color:var(--ok)}
.err{background:rgba(239,68,68,.15); border:1px solid rgba(239,68,68,.45); color:var(--danger)}
.warn{background:rgba(245,158,11,.15); border:1px solid rgba(245,158,11,.45); color:var(--warn)}
#hud{position:absolute; right:20px; top:20px; z-index:3;
background:rgba(2,6,23,.55); border:1px solid rgba(148,163,184,.35);
padding:10px 12px; border-radius:12px; min-width:180px; backdrop-filter: blur(4px);}
#hud h3{margin:0 0 6px 0; font-size:13px; color:var(--accent)}
#rankList{font-size:12px; line-height:1.4}
</style>
</head>
<body>
<div class="wrap">
<div class="card">
<h2>ì°¸ê°€ì ì„¤ì •</h2>
<div class="controls">
<textarea id="names" placeholder="ì´ë¦„ì„ ë„ì–´ì“°ê¸°, ì‰¼í‘œ, ì¤„ë°”ê¿ˆìœ¼ë¡œ êµ¬ë¶„í•´ ì…ë ¥"></textarea>
<div class="row">
<button id="btnAdd">ì°¸ê°€ì ì¶”ê°€</button>
<button id="btnClear">ì´ˆê¸°í™”</button>
<button id="btnShuffle">ì„ê¸°</button>
</div>
<div class="tags" id="chips"></div>
<div class="row">
<button class="primary" id="btnStart">Start!</button>
<button class="warn" id="btnReset" disabled>Reset!</button>
</div>
</div>
<div class="log" id="log"></div>
</div>

<div class="card stageWrap">
<h2>Etch ì •ë©´ ìŠ¹ë¶€!</h2>
<div id="hud">
<h3>ğŸ† ì‹¤ì‹œê°„ Top 3</h3>
<div id="rankList">-</div>
</div>
<canvas id="stage"></canvas>
</div>

<div class="card">
<h2>í˜„í™©</h2>
<div class="status" id="status"></div>
<div class="board">
<h2>ìµœì¢… ë“±ìˆ˜</h2>
<table>
<thead><tr><th style="width:56px">ìˆœìœ„</th><th>ì´ë¦„</th><th>ìƒíƒœ</th><th>ì‹œê°„</th></tr></thead>
<tbody id="tbody"></tbody>
</table>
</div>
</div>
</div>

<script>
window.addEventListener('DOMContentLoaded', () => {
const $ = s=>document.querySelector(s);
const namesEl = $('#names'), chips = $('#chips');
const btnAdd = $('#btnAdd'), btnClear = $('#btnClear'), btnStart = $('#btnStart'), btnReset = $('#btnReset'), btnShuffle = $('#btnShuffle');
const logEl = $('#log'), statusEl = $('#status'), tbody = $('#tbody');
const canvas = $('#stage'); const ctx = canvas.getContext('2d');
const hudList = $('#rankList');

// ==== audio (ì§§ê³  ì¡°ìš©í•˜ê²Œ) ====
let ac; function beep(type='norm', vol=0.02, dur=0.12){
try{
if(!ac) ac = new (window.AudioContext||window.webkitAudioContext)();
const o = ac.createOscillator(); const g = ac.createGain();
let f = 440;
if(type==='start') f=220; else if(type==='swap') f=660; else if(type==='err') f=150; else if(type==='finish') f=880; else if(type==='super') f=820;
o.frequency.value=f; g.gain.value=vol;
o.connect(g); g.connect(ac.destination);
o.start(); o.stop(ac.currentTime+dur);
}catch(e){}
}

// ==== layout ====
const wafer = {};
const fireworks = [];
function resize(){
const dpr = Math.max(1, window.devicePixelRatio||1);
canvas.width = Math.floor(canvas.clientWidth*dpr);
canvas.height = Math.floor(canvas.clientHeight*dpr);
ctx.setTransform(1,0,0,1,0,0); ctx.scale(dpr,dpr);
const padX = 32;
wafer.x = padX; wafer.w = canvas.clientWidth - padX*2;
wafer.h = Math.min(420, canvas.clientHeight - 120);
wafer.y = (canvas.clientHeight - wafer.h)/2;
wafer.innerH = wafer.h * 0.92;
}
resize(); window.addEventListener('resize', resize);

  // ê¸°ì¡´ í•¨ìˆ˜ë“¤ ì‚¬ì´ì— ë‹¤ìŒ í•¨ìˆ˜ë“¤ ì¶”ê°€
function createFirework(x, y, hue) {
    const particleCount = 100 + Math.floor(Math.random() * 50);
    for (let i = 0; i < particleCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 4;
        const life = 1000 + Math.random() * 500;
        fireworks.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life, age: 0, hue
        });
    }
    beep('finish', 0.03, 0.3);
}

function updateFireworks(dt) {
    for (let i = fireworks.length - 1; i >= 0; i--) {
        const f = fireworks[i];
        f.age += dt;
        f.x += f.vx * (dt / 16);
        f.y += f.vy * (dt / 16);
        f.vy += 0.05;
        const alpha = Math.max(0, 1 - f.age / f.life);
        if (alpha <= 0) {
            fireworks.splice(i, 1);
            continue;
        }
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = `hsla(${f.hue}, 100%, 60%, ${alpha * 0.7})`;
        ctx.beginPath();
        ctx.arc(f.x, f.y, 2 * alpha, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}
// ==== state ====
const ERR = { NONE:0, IGNITION:1, EPD_MIN:2, EPD_MAX:3, DOUBLE:4 };
const state = { players:[], running:false, startAt:0, locked:false, swapNext:0, chaos:0, slowmo:false, finished:false, swapCount:0, swapMax:3, finishSpeedSet:false };

// ==== UI helpers ====
function log(msg, level='info'){
const p = document.createElement('div');
const color = level==='err' ? 'var(--danger)' : level==='warn' ? 'var(--warn)' : 'var(--muted)';
p.style.color = color; p.textContent = msg; logEl.appendChild(p); logEl.scrollTop = logEl.scrollHeight;
}
function parseNames(text){ return text.split(/[,\s]+/).map(s=>s.trim()).filter(Boolean); }

function renderChips(){
chips.innerHTML='';
state.players.forEach((p)=>{
const d = document.createElement('div'); d.className='tag'; d.textContent = p.name; chips.appendChild(d);
});
renderStatus();
}

// ==== participants ====
function addPlayersFromInput(){
const arr = parseNames(namesEl.value);
if(arr.length===0){ alert('ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”. (ë„ì–´ì“°ê¸°, ì‰¼í‘œ, ì¤„ë°”ê¿ˆ êµ¬ë¶„)'); return; }
const seen = new Set(state.players.map(p=>p.name));
arr.forEach(n=>{ if(!seen.has(n)) state.players.push({name:n}); });
namesEl.value=''; renderChips(); drawStatic();
}
function shufflePlayers(){
for(let i=state.players.length-1;i>0;i--){
const j=Math.floor(Math.random()*(i+1));
[state.players[i],state.players[j]]=[state.players[j],state.players[i]];
}
renderChips(); drawStatic();
}
function clearAll(){
if(state.running){ log('ì—ì¹˜ ì¤‘ ì´ˆê¸°í™” ë¶ˆê°€', 'warn'); return; }
state.players = []; tbody.innerHTML='';
state.locked=false; state.slowmo=false; state.finished=false; state.swapCount=0; state.finishSpeedSet=false;
renderChips(); ctx.clearRect(0,0,canvas.width,canvas.height); drawStatic();
btnStart.disabled=false; btnReset.disabled=true;
log('ì´ˆê¸°í™” ì™„ë£Œ');
}
btnAdd.onclick = addPlayersFromInput;
btnClear.onclick = clearAll;
btnShuffle.onclick = shufflePlayers;

// ==== race setup ====
function decideErrorsAndTargets(){
const contenders = [];
const base = 12 + Math.random()*4;
state.players.forEach(p=>{
p.progress = 0; p.done=false; p.errType=0; p.errTriggered=false; p.note='';
p.phase = Math.random()*Math.PI*2;
p.boostMag = 0; p.boostEnd = 0;
p.superEligible = Math.random()<0.05; p.super=false; p.superTrigger = 5 + Math.random()*65; // 5% ìŠˆí¼ì—ì¹˜
p.finalRank = null;
p.msgText=''; p.msgUntil=0; p.msgCooldown=0; p.lastSpd=null;
p.lateBoostUsed = false;
if(Math.random()<0.10){
p.errType = [ERR.IGNITION, ERR.EPD_MIN, ERR.EPD_MAX, ERR.DOUBLE][Math.floor(Math.random()*4)];
}
});
state.players.forEach(p=>{ if(p.errType!==ERR.IGNITION && p.errType!==ERR.EPD_MIN) contenders.push(p); });
const m = contenders.length;
const gaps = Array.from({length:m}, (_,i)=> m===1 ? 0 : (i*(0.18/(m-1))));
for(let i=gaps.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [gaps[i],gaps[j]]=[gaps[j],gaps[i]];}
contenders.forEach((p,i)=>{
p.targetT = base + gaps[i];
p.baseSpeed = 100 / p.targetT;
p.noiseAmp = 1.0 + Math.random()*1.0;
p.noiseFreq = 1.2 + Math.random()*2.0;
});
state.players.filter(p=>p.errType===ERR.IGNITION).forEach(p=>{ p.baseSpeed=0; p.done=true; p.finishTime=Infinity; p.note='IGNITION FAIL!'; });
state.players.filter(p=>p.errType===ERR.EPD_MIN).forEach(p=>{
p.stopAt = 30 + Math.random()*60; p.targetT = 8 + Math.random()*4; p.baseSpeed = p.stopAt / p.targetT;
p.noiseAmp = 0.8; p.noiseFreq=1.4;
});
state.players.filter(p=>p.errType===ERR.EPD_MAX).forEach(p=>{
const over = 101 + Math.random()*4; p.targetT = base + (Math.random()*0.18); p.baseSpeed = over / p.targetT;
});
state.players.filter(p=>p.errType===ERR.DOUBLE && !p.baseSpeed).forEach(p=>{
p.targetT = base + Math.random()*0.18; p.baseSpeed = 100/p.targetT;
});
}

function startRace(){
if(state.running){ log('ì´ë¯¸ ì§„í–‰ ì¤‘', 'warn'); return; }
if(state.players.length<2){ alert('ìµœì†Œ 2ëª… ì´ìƒ ì°¸ê°€ìë¥¼ ì¶”ê°€í•˜ì„¸ìš”.'); return; }
decideErrorsAndTargets();
state.running = true; state.locked=false; state.slowmo=false; state.finished=false; state.swapCount=0; state.finishSpeedSet=false;
state.startAt = performance.now();
state.swapNext = state.startAt + 1200 + Math.random()*800;
state.chaos = 0;
btnStart.disabled = true; btnReset.disabled = true;
log('Plasma on! Main etch Start!'); beep('start', 0.02, 0.18);
state.players.forEach(p=>{ if(p.errType===ERR.IGNITION) log(p.name+': IGNITION FAIL!','err'); });
requestAnimationFrame(step);
}
function resetRace(){
if(state.running){ log('ì—ì¹˜ ì¤‘ ë¦¬ì…‹ ë¶ˆê°€', 'warn'); return; }
state.players.forEach(p=>{ p.progress=0; p.done=false; p.note=''; p.boostEnd=0; p.boostMag=0; p.finishTime=undefined; p.finalRank=null; p.lateBoostUsed=false; p.super=false; });
tbody.innerHTML=''; renderChips(); drawStatic(); state.slowmo=false; state.finished=false; state.swapCount=0; state.finishSpeedSet=false;
btnStart.disabled=false; btnReset.disabled=true;
log('ì¥ë¹„ ë¦¬ì…‹ ì™„ë£Œ');
}
btnStart.onclick = startRace; btnReset.onclick = resetRace;

// ==== draw helpers ====
function drawStatic(){
ctx.clearRect(0,0,canvas.width,canvas.height);
drawWafer(ctx); drawGuides(ctx);
}
function drawWafer(toCtx){
toCtx.save();
toCtx.fillStyle = '#0f1622'; toCtx.strokeStyle = 'rgba(34,211,238,.35)'; toCtx.lineWidth = 2;
toCtx.fillRect(wafer.x, wafer.y, wafer.w, wafer.h);
toCtx.strokeRect(wafer.x, wafer.y, wafer.w, wafer.h);
toCtx.globalAlpha = 0.18; toCtx.strokeStyle = 'rgba(167,139,250,.45)';
for(let y=wafer.y+10; y<wafer.y+wafer.h; y+=14){
toCtx.beginPath(); toCtx.moveTo(wafer.x, y); toCtx.lineTo(wafer.x+wafer.w, y); toCtx.stroke();
}
toCtx.globalAlpha = 1; toCtx.restore();
}
function laneX(i, n){
const pad = 28; const innerW = wafer.w - pad*2;
return wafer.x + pad + innerW * ((i+0.5)/n);
}
function drawGuides(toCtx){
const n = state.players.length||1;
for(let i=0;i<n;i++){
const x = laneX(i,n);
toCtx.save();
toCtx.strokeStyle = 'rgba(255,255,255,.08)'; toCtx.lineWidth = 1;
toCtx.strokeRect(x-12, wafer.y+6, 24, wafer.innerH-6);
toCtx.restore();
}
}

// ==== particles ====
const particles = [];
function spawnSpark(x,y,h,boost=1){
const cnt = 2 + Math.floor(Math.random()*(boost>1?4:2));
for(let i=0;i<cnt;i++){
const ang = Math.PI + (Math.random()-0.5)*Math.PI*0.7;
const spd = (boost>1?2.4:1.3) + Math.random()*1.2;
const life = 420 + Math.random()*420;
particles.push({x,y,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd,life,age:0,h});
}
}
function stepSparks(dt){
for(let i=particles.length-1;i>=0;i--){
const p = particles[i]; p.age += dt;
const k = dt/16; p.x += p.vx*k; p.y += p.vy*k; p.vx*=0.985; p.vy*=0.985;
const a = Math.max(0,1 - p.age/p.life); if(a<=0){ particles.splice(i,1); continue; }
ctx.save();
ctx.globalCompositeOperation='lighter';
ctx.fillStyle = `hsla(${p.h}, 100%, ${55*a+30}%, ${0.9*a})`;
ctx.beginPath(); ctx.arc(p.x,p.y, 1.8*a+0.6, 0, Math.PI*2); ctx.fill();
ctx.restore();
}
}

// ==== labels ====
function drawNameTag(toCtx, text, x, y, color, isLarge = false) {
    const padX = isLarge ? 12 : 8;
    const h = isLarge ? 24 : 18;
    const rx = isLarge ? 12 : 9;
    toCtx.save();
    toCtx.font = isLarge ? '700 14px ui-sans-serif, system-ui' : '700 12px ui-sans-serif, system-ui';
    const w = toCtx.measureText(text).width + padX * 2;
    toCtx.fillStyle = 'rgba(0, 0, 0, 0.35)';
    roundRect(toCtx, x - w / 2, y, w, h, rx);
    toCtx.fill();
    toCtx.strokeStyle = color;
    toCtx.lineWidth = 1;
    roundRect(toCtx, x - w / 2, y, w, h, rx);
    toCtx.stroke();
    toCtx.fillStyle = color;
    toCtx.textAlign = 'center';
    toCtx.textBaseline = 'middle';
    toCtx.fillText(text, x, y + h / 2 + 1);
    toCtx.restore();
}

function drawBubble(toCtx, text, x, y, hue){
toCtx.save();
toCtx.font = '800 11px ui-sans-serif, system-ui';
const w = toCtx.measureText(text).width + 12;
toCtx.fillStyle=`hsla(${hue}, 90%, 60%, .18)`; roundRect(toCtx, x - w/2, y, w, 16, 8); toCtx.fill();
toCtx.strokeStyle=`hsla(${hue}, 90%, 60%, .7)`; toCtx.lineWidth=1; roundRect(toCtx, x - w/2, y, w, 16, 8); toCtx.stroke();
toCtx.fillStyle='rgba(236,253,245,.95)'; toCtx.textAlign='center'; toCtx.textBaseline='middle'; toCtx.fillText(text, x, y+8);
toCtx.restore();
}
function drawRankBadge(toCtx, text, x, y){
toCtx.save();
toCtx.font = '800 12px ui-sans-serif, system-ui';
const w = toCtx.measureText(text).width + 12;
toCtx.fillStyle='rgba(2,6,23,.8)'; roundRect(toCtx, x - w/2, y, w, 16, 8); toCtx.fill();
toCtx.strokeStyle='rgba(34,211,238,.85)'; toCtx.lineWidth=1; roundRect(toCtx, x - w/2, y, w, 16, 8); toCtx.stroke();
toCtx.fillStyle='rgba(224,242,254,.95)'; toCtx.textAlign='center'; toCtx.textBaseline='middle'; toCtx.fillText(text, x, y+8);
toCtx.restore();
}

function carveTrench(p, idx, now) {
    const n = state.players.length;
    const x = laneX(idx, n);
    const hue = (idx * 53) % 360;
    const top = wafer.y + 6;
    const maxDepth = wafer.innerH - 6;
    const depth = Math.min(1.05, p.progress / 100) * maxDepth;
    const tipY = top + depth;
    const isLastStretch = p.progress >= 90 && !p.done;  // 90% ì´ìƒ êµ¬ê°„

    // 1. íŠ¸ë Œì¹˜ ê·¸ë¦¬ê¸° (90% ì´ìƒì¼ ë•Œ 3ë°° í™•ëŒ€)
    drawProfile(ctx, x, top, depth, hue, isLastStretch, isLastStretch ? 3 : 1);

    // 2. ë°˜ì§ì„ íš¨ê³¼ (90% ì´ìƒì¼ ë•Œ ë” ìì£¼)
    if (isLastStretch && Math.random() < 0.4) {
        spawnSpark(x + (Math.random() - 0.5) * 20, tipY, hue, 2.0);
    }

    // 3. ì´ë¦„ íƒœê·¸ (90% ì´ìƒì¼ ë•Œ ë” í¬ê³  ê°•ì¡°)
    const tagColor = p.super ? 'rgba(250, 204, 21, 0.95)' 
        : (p.done ? (p.note && p.note.includes('ERR') ? 'rgba(239, 68, 68, 0.95)' 
        : (p.note === 'DOUBLE ETCH!' ? 'rgba(245, 158, 11, 0.95)' : 'rgba(16, 185, 129, 0.95)')) 
        : (isLastStretch ? 'rgba(255, 255, 255, 0.95)' : 'rgba(214, 226, 241, 0.95)'));
    const label = p.super ? `${p.name} âš¡` 
        : (p.done ? (p.note ? `${p.name} â€¢ ${p.note}` : p.name) 
        : (isLastStretch ? `ğŸ”¥ ${p.name} (${(100 - p.progress).toFixed(1)}% ë‚¨ìŒ) ğŸ”¥` : p.name));
    drawNameTag(ctx, label, x, tipY + 6, tagColor, isLastStretch);
}


function drawProfile(toCtx, x, top, depth, hue, isLastStretch, scale = 1) {
    const maxDepth = wafer.innerH - 6;
    const wTop = 26 * scale, wBottom = 20 * scale;  // 90% ì´ìƒì¼ ë•Œ í­ í™•ëŒ€
    const w = (wTop - (wTop - wBottom) * (depth / maxDepth));
    const half = w / 2;
    const rough = (y) => Math.sin(y * 0.08) * 1.1 + Math.sin(y * 0.23) * 0.55;

    const path = new Path2D();
    path.moveTo(x - half + rough(0), top);
    for (let i = 1; i <= 10; i++) {
        const yy = top + (depth / 10) * i;
        const hw = (w / 2) - (i / 10) * 2.0;
        path.lineTo(x - hw + rough(yy), yy);
    }
    for (let i = 10; i >= 0; i--) {
        const yy = top + (depth / 10) * i;
        const hw = (w / 2) - (i / 10) * 2.0;
        path.lineTo(x + hw - rough(yy), yy);
    }
    path.closePath();

    // 1. ì œê±°(ì—ì¹­) íš¨ê³¼
    toCtx.save();
    toCtx.globalCompositeOperation = 'destination-out';
    toCtx.fill(path);
    toCtx.restore();

    // 2. ë¹› ë°˜ì‚¬/í”Œë¼ì¦ˆë§ˆ íš¨ê³¼ (90% ì´ìƒì¼ ë•Œ ë” ë°ê²Œ)
    toCtx.save();
    const g1 = toCtx.createLinearGradient(x, top, x, top + depth);
    g1.addColorStop(0, `hsla(${hue}, 90%, 60%, ${isLastStretch ? 0.4 : 0.2})`);
    g1.addColorStop(1, `hsla(${hue}, 90%, 60%, ${isLastStretch ? 0.7 : 0.3})`);
    toCtx.globalCompositeOperation = 'lighter';
    toCtx.fillStyle = g1;
    toCtx.fill(path);
    toCtx.restore();

    // 3. ê²½ê³„ì„  ê°•ì¡° (90% ì´ìƒì¼ ë•Œ ë” ë‘ê»ê²Œ)
    toCtx.save();
    toCtx.strokeStyle = `hsla(${hue}, 100%, 75%, ${isLastStretch ? 0.9 : 0.6})`;
    toCtx.lineWidth = isLastStretch ? 2.0 : 1.0;
    toCtx.stroke(path);
    toCtx.restore();

    // 4. 90% ì´ìƒì¼ ë•Œ ë°˜ì§ì„ íš¨ê³¼
    if (isLastStretch && Math.random() < 0.3) {
        toCtx.save();
        toCtx.globalCompositeOperation = 'lighter';
        toCtx.fillStyle = `hsla(${hue}, 100%, 80%, 0.7)`;
        toCtx.beginPath();
        toCtx.arc(
            x + (Math.random() - 0.5) * w * 0.5,
            top + depth - 5 + Math.random() * 10,
            1.5 + Math.random() * 1.5,
            0,
            Math.PI * 2
        );
        toCtx.fill();
        toCtx.restore();
    }
}


function drawLeaderLine(leader) {
if(!leader) return;
const idx = state.players.indexOf(leader);
const n = state.players.length;
const x = laneX(idx,n);
const top = wafer.y+6;
const maxDepth = wafer.innerH-6;
const depth = Math.min(1.05, leader.progress/100) * maxDepth;
const y = top + depth;
const now = performance.now();

// 1ìœ„ ë¬´ì§€ê°œ íš¨ê³¼
ctx.save();
const hue = (now * 0.05) % 360; // ì‹œê°„ì— ë”°ë¼ ìƒ‰ìƒ ë³€í™”
ctx.shadowColor = `hsla(${hue}, 100%, 50%, 0.7)`;
ctx.shadowBlur = 20;
ctx.shadowOffsetX = 0;
ctx.shadowOffsetY = 0;

const label = `ğŸ‘‘ ${leader.name}`;
ctx.font = '800 16px ui-sans-serif, system-ui';
const lw = ctx.measureText(label).width + 30;
const lh = 28;

// ë¬´ì§€ê°œ ê·¸ë¼ë°ì´ì…˜ ë°°ê²½
const gradient = ctx.createLinearGradient(x - lw/2, y - lh - 10, x + lw/2, y - 10);
gradient.addColorStop(0, 'rgba(255,0,0,0.8)');
gradient.addColorStop(0.2, 'rgba(255,165,0,0.8)');
gradient.addColorStop(0.4, 'rgba(255,255,0,0.8)');
gradient.addColorStop(0.6, 'rgba(0,128,0,0.8)');
gradient.addColorStop(0.8, 'rgba(0,0,255,0.8)');
gradient.addColorStop(1, 'rgba(128,0,128,0.8)');

ctx.fillStyle = gradient;
roundRect(ctx, x - lw/2, y - lh - 10, lw, lh, 14);
ctx.fill();

// í…Œë‘ë¦¬
ctx.strokeStyle = 'rgba(255,255,255,0.9)';
ctx.lineWidth = 2;
roundRect(ctx, x - lw/2, y - lh - 10, lw, lh, 14);
ctx.stroke();

// í…ìŠ¤íŠ¸
ctx.fillStyle = 'rgba(255,255,255,0.95)';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillText(label, x, y - lh/2 - 10);
ctx.restore();
}
function drawLastPlace(player) {
if (!player) return;
const idx = state.players.indexOf(player);
const n = state.players.length;
const x = laneX(idx, n);
const top = wafer.y + 6;
const maxDepth = wafer.innerH - 6;
const depth = Math.min(1.05, player.progress / 100) * maxDepth;
const y = top + depth;
const now = performance.now();

// ê¼´ì°Œ ë¹¨ê°„ìƒ‰ ê°•ì¡° íš¨ê³¼
ctx.save();
const flashIntensity = 0.5 + 0.5 * Math.sin(now * 0.01); // ê¹œë¹¡ì„ íš¨ê³¼
const hue = 0; // ë¹¨ê°„ìƒ‰
const saturation = 100;
const lightness = 50 + 20 * flashIntensity;

ctx.shadowColor = `hsla(${hue}, ${saturation}%, 50%, ${0.3 + flashIntensity * 0.4})`;
ctx.shadowBlur = 15;
ctx.shadowOffsetX = 0;
ctx.shadowOffsetY = 0;

const label = `ğŸ’¥ ${player.name}`;
ctx.font = '800 15px ui-sans-serif, system-ui';
const lw = ctx.measureText(label).width + 30;
const lh = 26;

// ë°°ê²½
ctx.fillStyle = `hsla(${hue}, ${saturation}%, ${20 + 5 * flashIntensity}%, 0.8)`;
roundRect(ctx, x - lw / 2, y - lh - 8, lw, lh, 12);
ctx.fill();

// í…Œë‘ë¦¬
ctx.strokeStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, 0.9)`;
ctx.lineWidth = 1 + flashIntensity;
roundRect(ctx, x - lw / 2, y - lh - 8, lw, lh, 12);
ctx.stroke();

// í…ìŠ¤íŠ¸
ctx.fillStyle = `hsla(${hue}, ${saturation}%, 90%, 1)`;
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillText(label, x, y - lh / 2 - 8);
ctx.restore();
}


function currentRanking(){
const arr = state.players.map(p=>p);
arr.sort((a,b)=>{
const ap = Math.min(105, a.progress||0), bp = Math.min(105, b.progress||0);
if(ap!==bp) return bp-ap;
if(a.finishTime!=null && b.finishTime!=null) return a.finishTime - b.finishTime;
return (a.targetT||999) - (b.targetT||999);
});
return arr;
}
function updateHUD(){
const list = currentRanking().slice(0,3);
hudList.innerHTML = list.map((p,i)=>{
const color = i===0? 'var(--accent)' : i===1? 'var(--violet)' : 'var(--ok)';
return `<div style="display:flex;justify-content:space-between;gap:12px;">
<span style="color:${color};font-weight:800">${i+1}.</span>
<span style="flex:1">${p.name}</span>
<span style="opacity:.8">${Math.min(105,p.progress).toFixed(1)}%</span>
</div>`;
}).join('');
}

// ==== race loop ====
let last = performance.now();
function avgProgress(){ const arr = state.players.filter(p=>!p.done && p.errType!==ERR.IGNITION); return arr.length? arr.reduce((a,b)=>a+b.progress,0)/arr.length : 0; }
function scheduleSwap(now){
if(state.swapCount >= state.swapMax) return;
state.swapNext = now + 1600 + Math.random()*1200; // ì™„ë§Œ
state.chaos = Math.min(1, state.chaos + 0.06);
const active = state.players.filter(p=>!p.done && p.errType!==ERR.IGNITION && p.errType!==ERR.EPD_MIN && !p.super);
if(active.length < 2) return;
active.sort((a,b)=>b.progress-a.progress);
const half = Math.floor(active.length/2);
const front = active.slice(0, half||1);
const back = active.slice(half||1);
front.forEach(p=>{ p.boostMag = -(0.06 + Math.random()*0.10 + 0.12*state.chaos); p.boostEnd = now + 320 + Math.random()*260; });
back.forEach(p=>{ p.boostMag = +(0.12 + Math.random()*0.16 + 0.18*state.chaos); p.boostEnd = now + 420 + Math.random()*360; });
state.swapCount++; beep('swap', 0.015, 0.06);
}

function step(now){
let dt = Math.min(50, now - last); last = now;
if(state.slowmo) dt *= 0.6;

if(state.running){
if(now >= state.swapNext) scheduleSwap(now);

let allDone = true;
const t = (now - state.startAt)/1000;

// ìŠ¬ë¡œëª¨ ì§„ì…
if(!state.locked && avgProgress() >= 90){
state.locked = true; state.slowmo = true; log('Main etch end! Over etch start!', 'warn');
}

const racers = state.players.filter(p=>!p.done && p.errType!==ERR.IGNITION);
const sorted = [...racers].sort((a,b)=>b.progress-a.progress);
const leaderProgress = (sorted[0] && sorted[0].progress) || 0;

for(const p of state.players){
if(p.done) continue;
if(p.errType===ERR.IGNITION){ p.done=true; p.finishTime=Infinity; p.note='IGNITION FAIL!'; continue; }

// 5% ìŠˆí¼ì—ì¹˜: ì†ë„ ì œí•œ ë¬´ì‹œí•˜ê³  100%ê¹Œì§€ ë‹¨ìˆ¨ì—
if(!p.super && p.superEligible && p.progress >= p.superTrigger){
p.super = true; beep('super',0.02,0.16); log(`${p.name}: SUPER!`, 'warn');
}

let spd;
if(p.super){
spd = 280; // ë§¤ìš° ë¹ ë¥´ê²Œ
} else {
spd = (state.locked && p.finishSpeed!=null) ? p.finishSpeed : (p.baseSpeed||0);
const wobble = Math.sin(p.phase + t*Math.PI*2*(p.noiseFreq||1.5)) * (p.noiseAmp||1);
spd += wobble * 0.5;

// ìŠ¤ì™‘ í„ìŠ¤ ì˜í–¥
if(p.boostEnd && now < p.boostEnd) spd *= (1 + p.boostMag);
else { p.boostMag = 0; p.boostEnd = 0; }

// ì „ë°˜ë¶€ ê°€ë²¼ìš´ ë°´ë”©
const rank = sorted.indexOf(p);
if(!state.locked){
const bandLo=0.96, bandHi=1.08;
const k = (racers.length>1? (racers.length-1-rank)/(racers.length-1) : 0);
spd *= (bandLo + k*(bandHi-bandLo));
}
}

// ë§‰íŒ ì—­ì „: 80% ì´í›„ ë’¤ì²˜ì§„ ì„ ìˆ˜ ê°€ì† ê¸°íšŒ
if(!p.lateBoostUsed && !p.done && p.progress >= 80 && p.progress < 99){
const behind = (leaderProgress - p.progress);
if(behind > 1.5){
const chance = Math.min(0.6, 0.15 + behind*0.08 + Math.random()*0.2);
if(Math.random() < chance){
p.lateBoostUsed = true;
const mag = 0.8 + Math.random()*1.6 + Math.min(2.2, behind*0.12);
p.boostMag = mag; p.boostEnd = now + 600 + Math.random()*900;
p.msgText = 'ì˜¬ íŒŒë¼ë¯¸í„° ì•ˆì •í™”!'; p.msgUntil = now + 1200; p.msgCooldown = now + 1400;
beep('super',0.02,0.14);
}
}
}

// ì†ë„ ë³€í™” ë²„ë¸”
const eff = Math.max(0.0001, spd);
if(p.lastSpd!=null && now>p.msgCooldown){
const ratio = eff / Math.max(0.0001, p.lastSpd);
if(ratio <= 0.82){ p.msgText = 'ë¦¬í”Œë ‰íŠ¸ ìƒìŠ¹!'; p.msgUntil = now + 1000; p.msgCooldown = now + 1200; }
else if(ratio >= 1.18){ p.msgText = 'ì˜¬ íŒŒë¼ë¯¸í„° ì•ˆì •í™”!'; p.msgUntil = now + 1000; p.msgCooldown = now + 1200; }
}
p.lastSpd = eff;

// ì§„í–‰/ì™„ë£Œ/ì˜¤ë¥˜ íŒì •
if(p.errType===ERR.EPD_MIN){
if(!p.errTriggered){
p.progress += Math.max(0, p.super? 280 : spd) * (dt/1000);
if(!p.super && p.progress >= p.stopAt){ p.errTriggered=true; p.done=true; p.finishTime=Infinity; p.note='EPD MIN ERR'; log(p.name+': '+p.note,'err'); beep('err',0.02,0.1); }
else { allDone=false; }
}
continue;
}

p.progress += Math.max(0, spd) * (dt/1000);

if(p.errType===ERR.EPD_MAX){
if(p.progress>=102){ p.done=true; p.finishTime=(now-state.startAt); p.note='EPD MAX ERR'; log(p.name+': '+p.note,'err'); beep('err',0.02,0.1); }
else { allDone=false; }
} else {
if(p.progress>=100){ p.done=true; p.finishTime=(now-state.startAt); p.note = (p.errType===ERR.DOUBLE)? 'DOUBLE ETCH!' : 'DONE'; if(p.errType===ERR.DOUBLE){ log(p.name+': '+p.note,'warn'); beep('swap',0.015,0.08);} else {beep('finish',0.02,0.12);} }
else { allDone=false; }
}
}

// ê²°ìŠ¹ êµ¬ê°„ ë³´ì •(ìŠ¬ë¡œëª¨ ì§„ì… ì§í›„ 1íšŒ)
if(state.locked && !state.finishSpeedSet){
const survivors = state.players.filter(p=>!p.done && p.errType!==ERR.IGNITION && p.errType!==ERR.EPD_MIN && !p.super);
const baseFinish = (now - state.startAt)/1000 + 1.2 + Math.random()*0.2;
survivors.forEach((p,i)=>{
const remain = Math.max(0, 100 - p.progress);
const jitter = (i/(survivors.length-1+1e-9))*0.18;
const targetArrival = baseFinish + jitter;
p.finishSpeed = remain / Math.max(0.2, targetArrival);
});
state.finishSpeedSet = true;
}

// draw
ctx.clearRect(0,0,canvas.width,canvas.height);
drawWafer(ctx); drawGuides(ctx);
state.players.forEach((p,i)=> carveTrench(p,i, now));
const ranked = currentRanking();
const leader = ranked[0];
if (leader) drawLeaderLine(leader);
if (ranked.length > 1) {
drawLastPlace(ranked[ranked.length-1]);
}
stepSparks(dt);
updateHUD();

// ê¸°ì¡´ step() í•¨ìˆ˜ ë‚´ë¶€ì˜ allDone ì²˜ë¦¬ ë¶€ë¶„ì„ ì°¾ì•„ì„œ ì „ì²´ êµì²´
if (allDone) {
    state.running = false;
    state.finished = true;
    btnReset.disabled = false;
    btnStart.disabled = false;
    log('Etch end â€” ê²°ê³¼ ì§‘ê³„ ì™„ë£Œ');
    assignRanks();
    renderStatus();
    renderBoard();
    beep('finish', 0.025, 0.2);

    for (let i = 0; i < 5; i++) {
        setTimeout(() => {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height * 0.5;
            const hue = (i * 60) % 360;
            createFirework(x, y, hue);
        }, i * 300);
    }
}
 else {
renderStatus();
}
} else {
// ì¢…ë£Œ í›„ì—ë„ íŠ¸ë Œì¹˜ ìœ ì§€
ctx.clearRect(0,0,canvas.width,canvas.height);
drawWafer(ctx); drawGuides(ctx);
if(state.finished){
const now2 = performance.now();
state.players.forEach((p,i)=> carveTrench(p,i, now2));
drawLeaderLine(currentRanking()[0]);
}}
   updateFireworks(dt);
  updateHUD();
  requestAnimationFrame(step);
}



  
function assignRanks(){
const finishers = state.players.filter(p=>p.done && p.note!=='DOUBLE ETCH!' && !(p.note&&p.note.includes('ERR')) && p.finishTime!==Infinity)
.sort((a,b)=>a.finishTime-b.finishTime);
let r = 1; finishers.forEach(p=>p.finalRank=r++);
state.players.filter(p=>p.note==='DOUBLE ETCH!').forEach(p=>p.finalRank=null);
state.players.filter(p=>p.note && (p.note.includes('ERR') || p.note==='IGNITION FAIL!')).forEach(p=>p.finalRank=null);
}


function renderStatus(){
statusEl.innerHTML='';

let arr;
if(state.finished){
arr = state.players.slice().sort((a,b)=>{
if(a.finishTime===undefined || a.finishTime===Infinity) return 1;
if(b.finishTime===undefined || b.finishTime===Infinity) return -1;
return a.finishTime - b.finishTime;
});
} else {
arr = currentRanking();
}

arr.forEach((p,i)=>{
const d = document.createElement('div'); d.className='chip';
const stat = p.done ? (p.note||'DONE') : (p.super?'ê°€ì†ì¤‘':'ì§„í–‰ì¤‘');
d.innerHTML = `<span style="width:10px;height:10px;border-radius:999px;background:${
p.done ? (
p.note && p.note.includes('ERR')
? 'var(--danger)'
: (p.note==='DOUBLE ETCH!' ? 'var(--warn)' : 'var(--ok)')
) : (p.super?'var(--warn)':'var(--accent)')
};display:inline-block"></span>`+
`<b>${i+1}. ${p.name}</b> <span style="opacity:.75">&nbsp;${Math.min(p.progress,105).toFixed(1)}% â€¢ ${stat}</span>`;
statusEl.appendChild(d);
});
}


function renderBoard(){
tbody.innerHTML='';
const done = state.players.filter(p=>p.done && p.note!=='DOUBLE ETCH!' && !(p.note&&p.note.includes('ERR')) && p.finishTime!==Infinity).sort((a,b)=>a.finishTime-b.finishTime);
let rank=1;
done.forEach(p=>{
const tr = document.createElement('tr');
tr.innerHTML = `<td>${rank++}</td><td>${p.name}</td><td><span class="pill ok">ì™„ë£Œ</span></td><td>${(p.finishTime/1000).toFixed(2)}s</td>`;
tbody.appendChild(tr);
});
state.players.filter(p=>p.done && p.note==='DOUBLE ETCH!').forEach(p=>{
const tr = document.createElement('tr'); tr.innerHTML = `<td>-</td><td>${p.name}</td><td><span class="pill warn">DOUBLE ETCH!</span></td><td>${(p.finishTime/1000).toFixed(2)}s</td>`; tbody.appendChild(tr);
});
state.players.filter(p=>p.note==='IGNITION FAIL!').forEach(p=>{
const tr = document.createElement('tr'); tr.innerHTML = `<td>DNF</td><td>${p.name}</td><td><span class="pill err">IGNITION FAIL!</span></td><td>IGNITION FAIL!</td>`; tbody.appendChild(tr);
});
state.players.filter(p=>p.note&&p.note.includes('ERR') && p.note!=='IGNITION FAIL!').forEach(p=>{
const tr = document.createElement('tr'); tr.innerHTML = `<td>DNF</td><td>${p.name}</td><td><span class="pill err">${p.note}</span></td><td>-</td>`; tbody.appendChild(tr);
});
}

function roundRect(ctx, x, y, w, h, r){
ctx.beginPath();
ctx.moveTo(x+r,y);
ctx.arcTo(x+w,y,x+w,y+h,r);
ctx.arcTo(x+w,y+h,x,y+h,r);
ctx.arcTo(x,y+h,x,y,r);
ctx.arcTo(x,y,x+w,y,r);
ctx.closePath();
}

// ìµœì´ˆ ë Œë”
drawStatic();
});
</script>
</body>
</html>
